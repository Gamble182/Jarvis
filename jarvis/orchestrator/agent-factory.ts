import { AgentAssignment, CapabilityDefinition, AgentContext, ProjectConfig } from '../shared/types.js';
import { CapabilityMatcher } from './capability-matcher.js';
import { writeFileSync, mkdirSync } from 'fs';
import { join } from 'path';

/**
 * Agent specification generated by the factory
 */
export interface AgentSpec {
  id: string;
  name: string;
  role: string;
  capabilities: string[];
  prompt: string;
  context: AgentContext;
  phase: string;
}

/**
 * AgentFactory - Creates agents with specific capability combinations
 *
 * This component:
 * - Instantiates agents based on assignments
 * - Loads relevant capability definitions
 * - Configures agent context and constraints
 * - Generates specialized prompts for each agent
 */
export class AgentFactory {
  private capabilityMatcher: CapabilityMatcher;

  constructor(capabilityMatcher: CapabilityMatcher) {
    this.capabilityMatcher = capabilityMatcher;
  }

  /**
   * Create agent specifications from assignments
   */
  public createAgents(
    assignments: AgentAssignment[],
    projectConfig: ProjectConfig
  ): AgentSpec[] {
    const agents: AgentSpec[] = [];

    for (const assignment of assignments) {
      const agent = this.createAgent(assignment, projectConfig);
      agents.push(agent);
    }

    return agents;
  }

  /**
   * Create a single agent from an assignment
   */
  private createAgent(
    assignment: AgentAssignment,
    projectConfig: ProjectConfig
  ): AgentSpec {
    const capabilities = assignment.capabilities.map(cap =>
      this.capabilityMatcher.getCapability(cap)
    ).filter((cap): cap is CapabilityDefinition => cap !== undefined);

    const name = this.generateAgentName(capabilities);
    const role = this.generateAgentRole(capabilities);
    const prompt = this.generateAgentPrompt(capabilities, assignment, projectConfig);

    const context: AgentContext = {
      projectContext: projectConfig,
      availableKnowledge: {},
      previousOutputs: {},
      constraints: projectConfig.constraints || {}
    };

    return {
      id: assignment.agentId,
      name,
      role,
      capabilities: assignment.capabilities,
      prompt,
      context,
      phase: assignment.phase
    };
  }

  /**
   * Generate a descriptive name for the agent
   */
  private generateAgentName(capabilities: CapabilityDefinition[]): string {
    if (capabilities.length === 0) return 'General Agent';

    // Determine primary category
    const categories = capabilities.map(c => c.category);
    const primaryCategory = this.getMostCommonElement(categories);

    // Create name based on capabilities
    const capabilityNames = capabilities.map(c => c.name);

    if (capabilityNames.some(n => n.includes('business'))) {
      return 'Business Strategy Agent';
    }
    if (capabilityNames.some(n => n.includes('architecture'))) {
      return 'Technical Architecture Agent';
    }
    if (capabilityNames.some(n => n.includes('ux'))) {
      return 'UX Design Agent';
    }
    if (capabilityNames.some(n => n.includes('development'))) {
      return 'Development Agent';
    }
    if (capabilityNames.some(n => n.includes('compliance') || n.includes('gdpr'))) {
      return 'Compliance & Legal Agent';
    }
    if (capabilityNames.some(n => n.includes('pricing'))) {
      return 'Pricing & Monetization Agent';
    }

    return `${primaryCategory.charAt(0).toUpperCase() + primaryCategory.slice(1)} Agent`;
  }

  /**
   * Generate role description for the agent
   */
  private generateAgentRole(capabilities: CapabilityDefinition[]): string {
    const capNames = capabilities.map(c =>
      c.name.split('-').map(word =>
        word.charAt(0).toUpperCase() + word.slice(1)
      ).join(' ')
    );

    return capNames.join(', ');
  }

  /**
   * Generate a specialized prompt for the agent
   */
  private generateAgentPrompt(
    capabilities: CapabilityDefinition[],
    assignment: AgentAssignment,
    projectConfig: ProjectConfig
  ): string {
    const sections: string[] = [];

    // Header
    sections.push(`# ${this.generateAgentName(capabilities)}`);
    sections.push('');

    // Role and responsibilities
    sections.push('## Your Role');
    sections.push(`You are a specialized agent with expertise in: ${capabilities.map(c => c.name).join(', ')}`);
    sections.push('');
    sections.push(`Phase: ${assignment.phase}`);
    sections.push(`Context: ${assignment.context}`);
    sections.push('');

    // Domain knowledge
    sections.push('## Your Domain Knowledge');
    const allKnowledge = new Set<string>();
    capabilities.forEach(cap => {
      cap.domainKnowledge.forEach(k => allKnowledge.add(k));
    });
    allKnowledge.forEach(knowledge => {
      sections.push(`- ${knowledge}`);
    });
    sections.push('');

    // Thinking patterns
    sections.push('## How You Approach Problems');
    const allPatterns = new Set<string>();
    capabilities.forEach(cap => {
      cap.thinkingPatterns.forEach(p => allPatterns.add(p));
    });
    allPatterns.forEach(pattern => {
      sections.push(`- ${pattern}`);
    });
    sections.push('');

    // Expected outputs
    sections.push('## What You Should Produce');
    const allOutputs = new Set<string>();
    capabilities.forEach(cap => {
      cap.outputFormats.forEach(o => allOutputs.add(o));
    });
    allOutputs.forEach(output => {
      sections.push(`- ${output}`);
    });
    sections.push('');

    // Context requirements
    sections.push('## Information You Need');
    const allContext = new Set<string>();
    capabilities.forEach(cap => {
      cap.requiredContext.forEach(c => allContext.add(c));
    });
    allContext.forEach(ctx => {
      sections.push(`- ${ctx}`);
    });
    sections.push('');

    // Collaboration
    sections.push('## Collaboration');
    const providesTo = new Set<string>();
    const receivesFrom = new Set<string>();
    capabilities.forEach(cap => {
      cap.collaboration.providesTo.forEach(p => providesTo.add(p));
      cap.collaboration.receivesFrom.forEach(r => receivesFrom.add(r));
    });

    if (providesTo.size > 0) {
      sections.push('### You provide information to:');
      providesTo.forEach(p => sections.push(`- ${p}`));
      sections.push('');
    }

    if (receivesFrom.size > 0) {
      sections.push('### You receive information from:');
      receivesFrom.forEach(r => sections.push(`- ${r}`));
      sections.push('');
    }

    // Project-specific context
    sections.push('## Project Context');
    sections.push(`**Project:** ${projectConfig.projectName}`);
    sections.push(`**Type:** ${projectConfig.projectType}`);
    sections.push(`**Domains:** ${projectConfig.domains.join(', ')}`);

    if (projectConfig.constraints.budget) {
      sections.push(`**Budget:** ${projectConfig.constraints.budget}`);
    }
    if (projectConfig.constraints.technicalComplexity) {
      sections.push(`**Complexity:** ${projectConfig.constraints.technicalComplexity}`);
    }
    if (projectConfig.constraints.regulatoryRequirements) {
      sections.push(`**Regulatory:** ${projectConfig.constraints.regulatoryRequirements.join(', ')}`);
    }
    sections.push('');

    // Working instructions
    sections.push('## Working Instructions');
    sections.push('1. Analyze the project requirements within your domain of expertise');
    sections.push('2. Apply your thinking patterns to develop solutions');
    sections.push('3. Produce outputs in the specified formats');
    sections.push('4. Collaborate with other agents as needed');
    sections.push('5. Always consider project constraints and context');
    sections.push('6. Document your reasoning and assumptions');
    sections.push('7. Identify risks and mitigation strategies');
    sections.push('8. Be specific and actionable in your recommendations');
    sections.push('');

    return sections.join('\n');
  }

  /**
   * Helper to get most common element in array
   */
  private getMostCommonElement<T>(arr: T[]): T {
    if (arr.length === 0) throw new Error('Array is empty');

    const counts = new Map<T, number>();
    for (const item of arr) {
      counts.set(item, (counts.get(item) || 0) + 1);
    }

    let maxCount = 0;
    let mostCommon = arr[0];
    for (const [item, count] of counts.entries()) {
      if (count > maxCount) {
        maxCount = count;
        mostCommon = item;
      }
    }

    return mostCommon;
  }

  /**
   * Save agent specifications to files
   */
  public saveAgentSpecs(agents: AgentSpec[], projectPath: string): void {
    const agentsDir = join(projectPath, 'agents');
    mkdirSync(agentsDir, { recursive: true });

    for (const agent of agents) {
      const agentFile = join(agentsDir, `${agent.id}-${agent.name.toLowerCase().replace(/\s+/g, '-')}.md`);
      writeFileSync(agentFile, agent.prompt, 'utf-8');
    }

    // Save agent assignments as JSON
    const assignmentsFile = join(projectPath, 'agent-assignments.json');
    const assignments = agents.map(a => ({
      id: a.id,
      name: a.name,
      role: a.role,
      capabilities: a.capabilities,
      phase: a.phase,
      status: 'pending'
    }));
    writeFileSync(assignmentsFile, JSON.stringify(assignments, null, 2), 'utf-8');
  }
}
